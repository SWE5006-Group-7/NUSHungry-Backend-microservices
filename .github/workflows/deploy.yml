# ============================================================================
# Kubernetes ÈÉ®ÁΩ≤Â∑•‰ΩúÊµÅ (‰ºòÂåñÁâà)
# ============================================================================
# Áî®ÈÄî: Â∞Ü Docker ÈïúÂÉèÈÉ®ÁΩ≤Âà∞ AWS EKS
# ÊîØÊåÅ: ÂºÄÂèëÁéØÂ¢É„ÄÅÊµãËØïÁéØÂ¢É„ÄÅÁîü‰∫ßÁéØÂ¢É
# Ëß¶Âèë: ÊâãÂä®Ëß¶Âèë„ÄÅÈïúÂÉèÊé®ÈÄÅÊàêÂäüÂêéËá™Âä®Ëß¶Âèë„ÄÅÊàñ repository_dispatch
# ‰ºòÂåñÁÇπ:
#   1. ‰øÆÂ§ç‰∫Ü Secret ÈÖçÁΩÆ,ÂåπÈÖç k8s deployment Ë¶ÅÊ±Ç
#   2. ‰ºòÂåñ‰∫ÜÈÉ®ÁΩ≤Âπ∂Ë°åÁ≠ñÁï•,ÊåâÊúçÂä°‰æùËµñÂÖ≥Á≥ªÂàÜÊâπÈÉ®ÁΩ≤
#   3. ÊîπËøõ‰∫ÜÂÅ•Â∫∑Ê£ÄÊü•Êú∫Âà∂,‰ΩøÁî® kubectl exec Êõø‰ª£Á´ØÂè£ËΩ¨Âèë
#   4. ÁßªÈô§‰∫Ü RDS ÂàùÂßãÂåñÊ≠•È™§(Â∑≤Âú®Âü∫Á°ÄËÆæÊñΩÂ±ÇÂÆåÊàê)
# ============================================================================

name: Deploy to Kubernetes

on:
  # ÊâãÂä®Ëß¶Âèë
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      services:
        description: 'Services to deploy (comma-separated, or "all")'
        required: true
        default: 'all'
        type: string
      tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'
        type: string
      skip_health_check:
        description: 'Skip health check after deployment'
        required: false
        default: false
        type: boolean

  # Áî± build-and-push workflow Ëß¶Âèë
  repository_dispatch:
    types: [deploy]

  # workflow_run Ëß¶Âèë (ÂΩì build-and-push ÊàêÂäüÂÆåÊàêÂêé)
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types:
      - completed
    branches:
      - main
      - develop

env:
  AWS_REGION: ap-southeast-1
  DEPLOYMENT_TIMEOUT: 900s

jobs:
  # =========================================================================
  # Job 1: Á°ÆÂÆöÈÉ®ÁΩ≤ÈÖçÁΩÆ
  # =========================================================================
  determine-config:
    name: Determine Deployment Config
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      cluster_name: ${{ steps.config.outputs.cluster_name }}
      namespace: ${{ steps.config.outputs.namespace }}
      services: ${{ steps.config.outputs.services }}
      tag: ${{ steps.config.outputs.tag }}

    steps:
      - name: Determine deployment configuration
        id: config
        run: |
          # ============================================================
          # 1. Á°ÆÂÆöÁéØÂ¢É
          # ============================================================
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            ENV="${{ github.event.client_payload.environment || 'dev' }}"
          else
            # workflow_run Ëß¶ÂèëÊó∂Ê†πÊçÆÂàÜÊîØÁ°ÆÂÆöÁéØÂ¢É
            if [ "${{ github.event.workflow_run.head_branch }}" == "main" ]; then
              ENV="dev"
            else
              ENV="dev"
            fi
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT

          # ============================================================
          # 2. Ê†πÊçÆÁéØÂ¢ÉËÆæÁΩÆÈõÜÁæ§ÂêçÁß∞ÂíåÂëΩÂêçÁ©∫Èó¥
          # ============================================================
          case $ENV in
            prod)
              CLUSTER="nushungry-prod-eks"
              NAMESPACE="nushungry-prod"
              ;;
            staging)
              CLUSTER="nushungry-staging-eks"
              NAMESPACE="nushungry-staging"
              ;;
            *)
              CLUSTER="nushungry-dev-eks"
              NAMESPACE="nushungry-dev"
              ;;
          esac

          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

          # ============================================================
          # 3. Á°ÆÂÆöË¶ÅÈÉ®ÁΩ≤ÁöÑÊúçÂä°
          # ============================================================
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.services }}" == "all" ]; then
              SERVICES='["user-service","cafeteria-service","review-service","media-service","preference-service"]'
            else
              SERVICES=$(echo '${{ github.event.inputs.services }}' | jq -R -s -c 'split(",") | map(select(length > 0) | gsub("^\\s+|\\s+$";""))')
            fi
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SERVICES='${{ github.event.client_payload.services }}'
          else
            # workflow_run Ëß¶ÂèëÊó∂ÈÉ®ÁΩ≤ÊâÄÊúâÊúçÂä°
            SERVICES='["user-service","cafeteria-service","review-service","media-service","preference-service"]'
          fi
          echo "services=$SERVICES" >> $GITHUB_OUTPUT

          # ============================================================
          # 4. Á°ÆÂÆöÈïúÂÉèÊ†áÁ≠æ
          # ============================================================
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.tag }}"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="${{ github.event.client_payload.tag }}"
          else
            # workflow_run: ‰ΩøÁî®Ëß¶ÂèëÂ∑•‰ΩúÊµÅÁöÑ commit SHA
            TAG="${{ github.sha }}"
          fi

          # Á°Æ‰øù TAG ‰∏ç‰∏∫Á©∫,‰ΩøÁî® github.sha ‰Ωú‰∏∫ÂêéÂ§áÂÄº
          if [ -z "$TAG" ]; then
            TAG="${{ github.sha }}"
            echo "‚ö†Ô∏è TAG was empty, using github.sha as fallback: $TAG"
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT

          # ============================================================
          # 5. ËæìÂá∫ÈÖçÁΩÆÊëòË¶Å
          # ============================================================
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìã Deployment Configuration"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Environment:  $ENV"
          echo "Cluster:      $CLUSTER"
          echo "Namespace:    $NAMESPACE"
          echo "Services:     $SERVICES"
          echo "Image Tag:    $TAG"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # =========================================================================
  # Job 2: È™åËØÅÈÉ®ÁΩ≤ÂâçÊèêÊù°‰ª∂
  # =========================================================================
  validate-prerequisites:
    name: Validate Prerequisites
    runs-on: ubuntu-latest
    needs: determine-config
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'repository_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify K8s manifests exist
        run: |
          SERVICES='${{ needs.determine-config.outputs.services }}'
          for service in $(echo $SERVICES | jq -r '.[]'); do
            manifest="k8s/services/${service}/deployment.yaml"
            if [ ! -f "$manifest" ]; then
              echo "‚ùå Missing manifest: $manifest"
              exit 1
            fi
            echo "‚úÖ Found manifest: $manifest"
          done

  # =========================================================================
  # Job 3: ÈÉ®ÁΩ≤Âà∞ EKS - Á¨¨‰∏ÄÊâπ (Êó†‰æùËµñÊúçÂä°)
  # =========================================================================
  deploy-batch-1:
    name: Deploy Batch 1 (user-service, media-service)
    runs-on: ubuntu-latest
    needs:
      - determine-config
      - validate-prerequisites
    environment: ${{ needs.determine-config.outputs.environment }}

    strategy:
      fail-fast: false
      max-parallel: 2  # ‰∏§‰∏™Êó†‰æùËµñÊúçÂä°Âπ∂Ë°åÈÉ®ÁΩ≤
      matrix:
        service:
          - user-service
          - media-service

    steps:
      # =====================================================================
      # 1. Ê£ÄÂá∫‰ª£Á†Å
      # =====================================================================
      - name: Checkout code
        uses: actions/checkout@v4

      # =====================================================================
      # 2. ÈÖçÁΩÆ AWS Âá≠ËØÅ
      # =====================================================================
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # =====================================================================
      # 3. ÈÖçÁΩÆ kubectl
      # =====================================================================
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.determine-config.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }}

          # È™åËØÅÈõÜÁæ§ËøûÊé•
          kubectl cluster-info
          kubectl get nodes

      # =====================================================================
      # 4. ÂàõÂª∫/Êõ¥Êñ∞ Namespace
      # =====================================================================
      - name: Ensure namespace exists
        run: |
          kubectl get namespace ${{ needs.determine-config.outputs.namespace }} || \
          kubectl create namespace ${{ needs.determine-config.outputs.namespace }}

      # =====================================================================
      # 5. ÂàõÂª∫/Êõ¥Êñ∞ Secrets (È¶ñÊ¨°ÈÉ®ÁΩ≤ÊàñÊõ¥Êñ∞)
      # =====================================================================
      - name: Create/Update Kubernetes Secrets
        run: |
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          # PostgreSQL Secret - ‰øÆÂ§ç: ‰ΩøÁî®‰∏â‰∏™Áã¨Á´ãÁöÑÊï∞ÊçÆÂ∫ì URL
          kubectl create secret generic postgres-secret \
            --from-literal=username=postgres \
            --from-literal=password='${{ secrets.DB_PASSWORD }}' \
            --from-literal=user-db-url='${{ secrets.USER_DB_URL }}' \
            --from-literal=cafeteria-db-url='${{ secrets.CAFETERIA_DB_URL }}' \
            --from-literal=preference-db-url='${{ secrets.PREFERENCE_DB_URL }}' \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

          # MongoDB Secret
          kubectl create secret generic mongodb-secret \
            --from-literal=username=admin \
            --from-literal=password='${{ secrets.MONGODB_PASSWORD }}' \
            --from-literal=uri='${{ secrets.MONGODB_URI }}' \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

          # Redis Secret
          kubectl create secret generic redis-secret \
            --from-literal=host='${{ secrets.REDIS_HOST }}' \
            --from-literal=port=6379 \
            --from-literal=password='${{ secrets.REDIS_PASSWORD }}' \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

          # JWT Secret
          kubectl create secret generic jwt-secret \
            --from-literal=secret='${{ secrets.JWT_SECRET }}' \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

          # Amazon MQ Secret
          kubectl create secret generic amazonmq-secret \
            --from-literal=host='${{ secrets.RABBITMQ_HOST }}' \
            --from-literal=port=5671 \
            --from-literal=username=admin \
            --from-literal=password='${{ secrets.RABBITMQ_PASSWORD }}' \
            --from-literal=vhost="/" \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "‚úÖ All secrets created/updated"

      # =====================================================================
      # 6. Êõ¥Êñ∞ÈÉ®ÁΩ≤Ê∏ÖÂçï‰∏≠ÁöÑÈïúÂÉèÊ†áÁ≠æ
      # =====================================================================
      - name: Update image tag in deployment manifest
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.determine-config.outputs.tag }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"
          ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          MANIFEST="k8s/services/${SERVICE}/deployment.yaml"

          # È™åËØÅÂÖ≥ÈîÆÂèòÈáè‰∏ç‰∏∫Á©∫
          if [ -z "$TAG" ]; then
            echo "‚ùå ERROR: TAG is empty!"
            echo "Debugging info:"
            echo "  github.event_name: ${{ github.event_name }}"
            echo "  github.sha: ${{ github.sha }}"
            echo "  needs.determine-config.outputs.tag: ${{ needs.determine-config.outputs.tag }}"
            exit 1
          fi

          echo "Updating $MANIFEST with:"
          echo "  Registry: ${ECR_REGISTRY}"
          echo "  Service: ${SERVICE}"
          echo "  Tag: ${TAG}"
          echo "  Namespace: ${NAMESPACE}"

          # ‰ΩøÁî® sed ÊõøÊç¢Âç†‰ΩçÁ¨¶ (‰ΩøÁî® @ ‰Ωú‰∏∫ÂàÜÈöîÁ¨¶ÈÅøÂÖç / ÂÜ≤Á™Å)
          sed -i "s@PLACEHOLDER_REGISTRY@${ECR_REGISTRY}@g" "$MANIFEST"
          sed -i "s@PLACEHOLDER_TAG@${TAG}@g" "$MANIFEST"

          # ÂêåÊó∂Êõ¥Êñ∞ namespace (ÊîØÊåÅÂ§öÁéØÂ¢ÉÈÉ®ÁΩ≤)
          sed -i "s@namespace: nushungry-dev@namespace: ${NAMESPACE}@g" "$MANIFEST"
          sed -i "s@namespace: nushungry-staging@namespace: ${NAMESPACE}@g" "$MANIFEST"
          sed -i "s@namespace: nushungry-prod@namespace: ${NAMESPACE}@g" "$MANIFEST"

          echo ""
          echo "Updated image line:"
          grep "image:" "$MANIFEST" | grep -v "#" | head -1

          echo ""
          echo "Validating YAML syntax..."
          if kubectl apply --dry-run=client -f "$MANIFEST" > /dev/null 2>&1; then
            echo "‚úÖ YAML syntax is valid"
          else
            echo "‚ùå YAML syntax error detected:"
            kubectl apply --dry-run=client -f "$MANIFEST"
            exit 1
          fi

      # =====================================================================
      # 7. Â∫îÁî® ConfigMap (Â¶ÇÊûúÂ≠òÂú®)
      # =====================================================================
      - name: Apply ConfigMaps
        run: |
          if [ -f "k8s/base/configmap.yaml" ]; then
            kubectl apply -f k8s/base/configmap.yaml -n ${{ needs.determine-config.outputs.namespace }}
          fi
        continue-on-error: true

      # =====================================================================
      # 8. ÈÉ®ÁΩ≤ÊúçÂä°
      # =====================================================================
      - name: Deploy ${{ matrix.service }}
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Deploying $SERVICE to $NAMESPACE..."

          # Â∫îÁî® Deployment
          kubectl apply -f k8s/services/${SERVICE}/deployment.yaml -n $NAMESPACE

          # Â∫îÁî® Service
          kubectl apply -f k8s/services/${SERVICE}/service.yaml -n $NAMESPACE

          # Â∫îÁî® HPA (Â¶ÇÊûúÂ≠òÂú®)
          if [ -f "k8s/services/${SERVICE}/hpa.yaml" ]; then
            kubectl apply -f k8s/services/${SERVICE}/hpa.yaml -n $NAMESPACE
          fi

      # =====================================================================
      # 9. Á≠âÂæÖÊªöÂä®Êõ¥Êñ∞ÂÆåÊàê
      # =====================================================================
      - name: Wait for rollout to complete
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Waiting for $SERVICE deployment to complete..."

          kubectl rollout status deployment/${SERVICE} \
            -n $NAMESPACE \
            --timeout=${{ env.DEPLOYMENT_TIMEOUT }}

      # =====================================================================
      # 10. È™åËØÅÈÉ®ÁΩ≤
      # =====================================================================
      - name: Verify deployment
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Pod status:"
          kubectl get pods -l app=${SERVICE} -n $NAMESPACE

          echo ""
          echo "Deployment status:"
          kubectl get deployment ${SERVICE} -n $NAMESPACE

          echo ""
          echo "Recent events:"
          kubectl get events -n $NAMESPACE \
            --field-selector involvedObject.name=${SERVICE} \
            --sort-by='.lastTimestamp' | tail -10

      # =====================================================================
      # 11. ÂÅ•Â∫∑Ê£ÄÊü• (‰ºòÂåñ: ‰ΩøÁî® kubectl exec)
      # =====================================================================
      - name: Health check
        if: github.event.inputs.skip_health_check != 'true'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Performing health check for $SERVICE..."

          # Ëé∑ÂèñÊúçÂä°Á´ØÂè£
          case $SERVICE in
            user-service) PORT=8081 ;;
            media-service) PORT=8085 ;;
            *) PORT=8080 ;;
          esac

          # Ëé∑Âèñ Pod ÂêçÁß∞
          POD_NAME=$(kubectl get pods -l app=${SERVICE} -n $NAMESPACE \
            -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$POD_NAME" ]; then
            echo "‚ùå No pod found for $SERVICE"
            exit 1
          fi

          # Á≠âÂæÖ Pod ËøõÂÖ• Running Áä∂ÊÄÅ
          kubectl wait --for=condition=ready pod/${POD_NAME} \
            -n $NAMESPACE \
            --timeout=300s

          # ‰ªé Pod ÂÜÖÈÉ®ÊµãËØïÂÅ•Â∫∑Á´ØÁÇπ
          if kubectl exec ${POD_NAME} -n $NAMESPACE -- \
            wget -q -O- http://localhost:${PORT}/actuator/health | grep -q "UP"; then
            echo "‚úÖ Health check passed for $SERVICE on port $PORT"
          else
            echo "‚ùå Health check failed for $SERVICE"
            kubectl logs ${POD_NAME} -n $NAMESPACE --tail=50
            exit 1
          fi
        continue-on-error: true

      # =====================================================================
      # 12. ËæìÂá∫ÈÉ®ÁΩ≤‰ø°ÊÅØ
      # =====================================================================
      - name: Output deployment info
        run: |
          echo "## üöÄ Deployment Complete: ${{ matrix.service }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: \`${{ needs.determine-config.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag**: \`${{ needs.determine-config.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace**: \`${{ needs.determine-config.outputs.namespace }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -l app=${{ matrix.service }} -n ${{ needs.determine-config.outputs.namespace }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # =========================================================================
  # Job 4: ÈÉ®ÁΩ≤Âà∞ EKS - Á¨¨‰∫åÊâπ (‰æùËµñÁ¨¨‰∏ÄÊâπÁöÑÊúçÂä°)
  # =========================================================================
  deploy-batch-2:
    name: Deploy Batch 2 (cafeteria, review, preference)
    runs-on: ubuntu-latest
    needs:
      - determine-config
      - deploy-batch-1  # ‰æùËµñÁ¨¨‰∏ÄÊâπÈÉ®ÁΩ≤ÂÆåÊàê
    environment: ${{ needs.determine-config.outputs.environment }}

    strategy:
      fail-fast: false
      max-parallel: 3  # ‰∏â‰∏™ÊúçÂä°Âπ∂Ë°åÈÉ®ÁΩ≤
      matrix:
        service:
          - cafeteria-service
          - review-service
          - preference-service

    steps:
      # Â§çÁî®Á¨¨‰∏ÄÊâπÁöÑÊâÄÊúâÊ≠•È™§,Âè™ÊòØË∑≥Ëøá Secrets ÂàõÂª∫(Â∑≤Âú®Á¨¨‰∏ÄÊâπÂàõÂª∫)
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.determine-config.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Update image tag in deployment manifest
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.determine-config.outputs.tag }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"
          ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          MANIFEST="k8s/services/${SERVICE}/deployment.yaml"

          # È™åËØÅÂÖ≥ÈîÆÂèòÈáè‰∏ç‰∏∫Á©∫
          if [ -z "$TAG" ]; then
            echo "‚ùå ERROR: TAG is empty!"
            echo "Debugging info:"
            echo "  github.event_name: ${{ github.event_name }}"
            echo "  github.sha: ${{ github.sha }}"
            echo "  needs.determine-config.outputs.tag: ${{ needs.determine-config.outputs.tag }}"
            exit 1
          fi

          echo "Updating $MANIFEST with:"
          echo "  Registry: ${ECR_REGISTRY}"
          echo "  Service: ${SERVICE}"
          echo "  Tag: ${TAG}"
          echo "  Namespace: ${NAMESPACE}"

          # ‰ΩøÁî® sed ÊõøÊç¢Âç†‰ΩçÁ¨¶ (‰ΩøÁî® @ ‰Ωú‰∏∫ÂàÜÈöîÁ¨¶ÈÅøÂÖç / ÂÜ≤Á™Å)
          sed -i "s@PLACEHOLDER_REGISTRY@${ECR_REGISTRY}@g" "$MANIFEST"
          sed -i "s@PLACEHOLDER_TAG@${TAG}@g" "$MANIFEST"

          # ÂêåÊó∂Êõ¥Êñ∞ namespace (ÊîØÊåÅÂ§öÁéØÂ¢ÉÈÉ®ÁΩ≤)
          sed -i "s@namespace: nushungry-dev@namespace: ${NAMESPACE}@g" "$MANIFEST"
          sed -i "s@namespace: nushungry-staging@namespace: ${NAMESPACE}@g" "$MANIFEST"
          sed -i "s@namespace: nushungry-prod@namespace: ${NAMESPACE}@g" "$MANIFEST"

          echo ""
          echo "Updated image line:"
          grep "image:" "$MANIFEST" | grep -v "#" | head -1

          echo ""
          echo "Validating YAML syntax..."
          if kubectl apply --dry-run=client -f "$MANIFEST" > /dev/null 2>&1; then
            echo "‚úÖ YAML syntax is valid"
          else
            echo "‚ùå YAML syntax error detected:"
            kubectl apply --dry-run=client -f "$MANIFEST"
            exit 1
          fi

      - name: Deploy ${{ matrix.service }}
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Deploying $SERVICE to $NAMESPACE..."

          kubectl apply -f k8s/services/${SERVICE}/deployment.yaml -n $NAMESPACE
          kubectl apply -f k8s/services/${SERVICE}/service.yaml -n $NAMESPACE

          if [ -f "k8s/services/${SERVICE}/hpa.yaml" ]; then
            kubectl apply -f k8s/services/${SERVICE}/hpa.yaml -n $NAMESPACE
          fi

      - name: Wait for rollout to complete
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          kubectl rollout status deployment/${SERVICE} \
            -n $NAMESPACE \
            --timeout=${{ env.DEPLOYMENT_TIMEOUT }}

      - name: Verify deployment
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Pod status:"
          kubectl get pods -l app=${SERVICE} -n $NAMESPACE

          echo ""
          echo "Deployment status:"
          kubectl get deployment ${SERVICE} -n $NAMESPACE

      - name: Health check
        if: github.event.inputs.skip_health_check != 'true'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          echo "Performing health check for $SERVICE..."

          # Ëé∑ÂèñÊúçÂä°Á´ØÂè£
          case $SERVICE in
            cafeteria-service) PORT=8083 ;;
            review-service) PORT=8084 ;;
            preference-service) PORT=8086 ;;
            *) PORT=8080 ;;
          esac

          POD_NAME=$(kubectl get pods -l app=${SERVICE} -n $NAMESPACE \
            -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$POD_NAME" ]; then
            echo "‚ùå No pod found for $SERVICE"
            exit 1
          fi

          kubectl wait --for=condition=ready pod/${POD_NAME} \
            -n $NAMESPACE \
            --timeout=300s

          if kubectl exec ${POD_NAME} -n $NAMESPACE -- \
            wget -q -O- http://localhost:${PORT}/actuator/health | grep -q "UP"; then
            echo "‚úÖ Health check passed for $SERVICE on port $PORT"
          else
            echo "‚ùå Health check failed for $SERVICE"
            kubectl logs ${POD_NAME} -n $NAMESPACE --tail=50
            exit 1
          fi
        continue-on-error: true

      - name: Output deployment info
        run: |
          echo "## üöÄ Deployment Complete: ${{ matrix.service }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: \`${{ needs.determine-config.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag**: \`${{ needs.determine-config.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace**: \`${{ needs.determine-config.outputs.namespace }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -l app=${{ matrix.service }} -n ${{ needs.determine-config.outputs.namespace }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # =========================================================================
  # Job 5: ÈÉ®ÁΩ≤ Ingress (ÊâÄÊúâÊúçÂä°ÈÉ®ÁΩ≤ÂÆåÊàêÂêé)
  # =========================================================================
  deploy-ingress:
    name: Deploy Ingress
    runs-on: ubuntu-latest
    needs:
      - determine-config
      - deploy-batch-2
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.determine-config.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Deploy Ingress
        run: |
          NAMESPACE="${{ needs.determine-config.outputs.namespace }}"

          if [ -f "k8s/ingress/ingress.yaml" ]; then
            kubectl apply -f k8s/ingress/ingress.yaml -n $NAMESPACE
            echo "‚úÖ Ingress deployed"

            # Á≠âÂæÖ ALB ÂàõÂª∫
            echo "Waiting for Load Balancer to be ready..."
            sleep 30

            # Ëé∑Âèñ ALB Âú∞ÂùÄ
            ALB_URL=$(kubectl get ingress -n $NAMESPACE \
              -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')

            if [ -n "$ALB_URL" ]; then
              echo "üåê Application available at: http://$ALB_URL"
              echo "ALB_URL=$ALB_URL" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è Ingress manifest not found, skipping..."
          fi
        continue-on-error: true

  # =========================================================================
  # Job 6: ÈÉ®ÁΩ≤ÊÄªÁªì
  # =========================================================================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs:
      - determine-config
      - deploy-batch-1
      - deploy-batch-2
      - deploy-ingress
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "# üéâ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ needs.determine-config.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: \`${{ needs.determine-config.outputs.cluster_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`${{ needs.determine-config.outputs.namespace }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: \`${{ needs.determine-config.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services Deployed" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          echo '${{ needs.determine-config.outputs.services }}' | jq . >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch 1 (user, media)**: ${{ needs.deploy-batch-1.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch 2 (cafeteria, review, preference)**: ${{ needs.deploy-batch-2.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Ingress**: ${{ needs.deploy-ingress.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Verification Commands" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Configure kubectl" >> $GITHUB_STEP_SUMMARY
          echo "aws eks update-kubeconfig --name ${{ needs.determine-config.outputs.cluster_name }} --region ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check pod status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods -n ${{ needs.determine-config.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check services" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get svc -n ${{ needs.determine-config.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check ingress" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get ingress -n ${{ needs.determine-config.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# View logs" >> $GITHUB_STEP_SUMMARY
          echo "kubectl logs -f deployment/<service-name> -n ${{ needs.determine-config.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Check overall deployment status
        run: |
          if [ "${{ needs.deploy-batch-1.result }}" != "success" ] || \
             [ "${{ needs.deploy-batch-2.result }}" != "success" ]; then
            echo "‚ùå Deployment failed!"
            exit 1
          fi
          echo "‚úÖ All services deployed successfully to ${{ needs.determine-config.outputs.environment }} environment!"
